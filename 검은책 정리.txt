JavaSE11부터 소스파일 모드 추가됨.
java커맨드는 .java파일을 직접 실행 가능.

package – import – class 순서

다른 패키지에 있는 클래스 이용할 때는 완전수식클래스명으로 불러야한다.

람다식을 둘러싼 블록의 안에서 선언된 로컬변수를
람다식 내에서 이용할 때에는 그 변수를 final로 선언하지 않으면 안된다.
int i = 0; X
final int i = 25; O
Supplier<Integer> foo = () -> i;
i++

인스턴스 변수 혹은 클래스 변수
//
로컬변수
이렇게 두 가지는 동시에 같은 이름으로 정의는 가능하지만
메소드 내에서 우선되는 건 로컬변수이다.

로컬변수는 반드시 초기화를 해야 한다.

모듈의 설정파일(module-info.java)
requires : 그 모듈이 이용하는 다른 모듈명을 기술한다.
서로 동시에 얽혀있으면 컴파일 에러 남.
module A{
    requires B;
}
module B{
    requires A;
}
exports : 외부에 공개하는 패키지를 선언한다.

java.base모듈은 자바의 기본적인 클래스라이브러리가 분류되어 있는 모듈로
어느 모듈에서도 필요한 것이기에 암묵적으로 requires되어 있다.

String.charAt(index)
인덱스 위치에 있는 한 글자 리턴

Character.isPlphabetic(String)
스트링이 알파벳이면 true

Character.isDigit(String)
스트링이 숫자이면 true

String.endsWith(String)
스트링의 마지막이 스트링으로 끝나면 true

String.substring(index1)
스트링에서 인덱스1 이후의 글자를 잘라서 출력
index1이 8이면 8에서 잘라서 그 이후의 글자를 출력

String.substring(index1, index2)
스트링의 인덱스1에서 인덱스2까지 잘라서 출력

jdeps --list-deps
java --show-module-resolution
클래스나 모듈의 의존관계를 알기 위한 커맨드

jmod describe
모듈 작성을 위한 커맨드

java Hello.java
java커맨드의 소스파일모드에 의한 실행

jar
여러 파일을 모아서 jar파일을 만드는 커맨드

추상메소드를 실장하는 것은 구상메소드

{}이게 있으면 실장했다는 뜻

추상클래스는 어중간한 놈이라
추상메소드 + 실장메소드 둘 다 가질 수 있음
추상메소드는 반드시 abstract를 붙여야 하고
실장 메소드는 반드시 {}가 있어야 한다

var는 형태 추론형

String.indexOf(String)
스트링에서 인수 스트링이 시작되는 지점의 인덱스를 리턴

푸리미디브형(기본 8가지 형태)

switch(str)
str이 null이면 NullPointerException으로 예외가 스로된다.

List<String> list = Arrays.asList(new String[]{"a","b","c"});
list.forEach(x -> {System.out.println(x);});
x의 데이터 형태로 알맞은 것은
String
(List안의 내용물이 String으로 선언되었으니까?)

javac -d bulid ex15/Sample.java ex15/Main.java
java -cp bulid ex15.Main
javac커맨드에서 -d옵션으로 출력처를 지정할 수 있음
지정 안하면 소스파일과 같은 장소에 클래스파일 출력됨
java커맨드에서 인수는 완전수식클래스명을 지정해야 함
java커맨드에서 기본 디렉토리 이외의 클래스파일을 실행할 때에는
-cp옵션으로 클래스패스 지정함
bulid는 빌드디렉토리 지정하는 것

LocalDate.now()
현재 시간을 정해진 형식으로 출력함
.with(TUESDAY)
다음 TUESDAY(화요일)로 변경하고
.getDayOfWeek()
요일을 Enum형식으로 출력한다.

추상메소드를 private로 선언할 수는 없다.
인터페이스는 public이외의 수식자로 선언할 수 없다
이너클래스는 아무 수식자 다 붙일 수 있다.

인터페이스는 실장메소드를 가질 수 있다.
어떻게? 유일하게 default 메소드를 통해서만.

인터페이스 특징
공개할려고 작정하고 만든 것
인스턴스화 할 수 없고, 실현하는 클래스가 필요(implement)
추상메소드를 정의함
자바8부터 디폴트메소드(실장된 {}) 사용 가능

추상클래스 특징
인터페이스를 실현한 클래스의 클래스의 공통 부분을 정의하기 위한 것
그대로 인스턴스화할 수 없고, 계승한 서브클래스가 필요함
추상메소드와 구상메소드 양 쪽 기술 가능

인터페이스는 final 사용 불가능
인터페이스는 abstract를 붙여서 선언이 가능함
원래는 없어도 컴파일러가 알아서 abstract 붙여서 해석해 주는 것

JDK를 모듈화한 이유
-어플리케이션 모듈과 JDK모듈의 링크가 쉽게 구축 가능
-세큐리티와 메인테넌스성의 향상(패키지 단위로의 정보 은닉)

12장 31번부터




