1. 리퀘스트 메소드 (☆는 단순히 정의되있는 거 묻는 문제)
PUT : 리소스의 변경(오키카에)을 요구 ★☆
GET : 리소스 요구 ☆
POST : 리소스 송신
DELETE : 리소스 삭제
HEAD : 리소스의 요구. 단, GET과 달리 리스폰스바디를 돌려주지 않음
OPTIONS : 서버의 조사
CONNECT : 터널을 엶 ☆
TRACE : 네트워크 경로의 조사

2. 스테타스 코드
정보
101 : 프로토콜의 교환
성공
200 : 성공
리다이렉트
301 : 영구적인 리다이렉트 ★
304 : 변경 없음. 캐쉬한 파일이 변경됨
307 : 일시적인 리다이렉트
클라이언트 에라
401 : 인증이 필요
403 : 악세스권이 필요
404 : 리소스가 발견되지 않음 ★
서버에러
500 : 서버측에서 에러가 발생

3. Basic 인증의 설명
- 유저명, 패스워드는 Autorization헤더에 추가되어 송신된다. ★
- 인증이 실패한 경우, 스테이터스 코드 401을 돌려준다. ★
- 거의 대부분의 브라우저나 Web서버에서 실장되어 있다. ★
- 유저명, 패스워드는 해시값화 하여 송신하지 않음. (위험성 〇)
- HTTPS를 이용하는 것이 바람직하지만 필수는 아님.

4. HTTP 쿠키
- 4KB정도의 데이터 보존이 가능하다.
- 브라우저에 데이터를 보존한다. ★
- JavaScript로 조작할 수 있다. ★
- HTTP, HTTPS 어느 쪽에서도 사용할 수 있다. ★
- 데이터의 유효기간을 설정할 필요가 있다.

5. HTTP로 이용되는 인증방법의 설명
- Digest인증은 유저명, 패스워드를 해시값화한다. ★
- Web어플리케이션에서는 Basic, Digest 이외의 독자적인 인증을 이용하는 것도 가능하다.

6. HTTP 리퀘스트의 설명 (잘못된 거 찾는 문제)
- 리퀘스트의 개시행에는 URL과 HTTP의 리퀘스트 메소드, HTTP버젼이 포함되어 있다.
- 메세지보디에는 브라우저에서의 송신 데이터가 포함되어 있다.
- HTTP의 리퀘스트 메소드가 GET인 경우, 메세지보디는 공백이어도 괜찮다.
- Content-Length헤더는 메세지보디의 사이즈를 설정한다.
- Accept-Language헤더는 브라우저가 이해 가능한 프로그래밍 언어를 설정하는 것이 아닌,
  브라우저가 받아들일 수 있는 자연언어(일본어, 영어 등)을 설정하기 위한 것이다. ★

7. JSON데이터의 우케이레를 나타내는 Accept헤더 필드의 기술
- Accept: application/json ★

8. 이하의 URL
   http://www.know.com/kw/sch/course.httml?cq=HTML#main
스키마://호스트명:포트번호/디렉토리/파일명
스키마~호스트명~포트번호까지를 오리지날이라고 부른다.
http://www.know.com ★
플래그먼트는 #으로 표시한다.
#main ★

9. HTTP(80) / HTTPS(443)의 기존포트번호 ★
0 ~ 1023을 웰노운 포트 번호
웰노운 포트 번호 쓰는 경우에는 생략 가능

10. HTTPS의 설명 (잘못된 것 고르는 문제)
- SSL/TLS프로토콜을 이용하여 통신을 암호화하고, 송수신을 한다.
- HTTP통신과 비교하여 Web서버의 부담이 높다.
- 암호화를 위해서는 인증국(CA)으로 부터 인증서를 취득할 필요가 있다.
- HTTP 헤더, 인잭션의 대책이 아닌, 나리스마시나 도청을 방지할 수 있다. ★
- HTTPS의 웰노운 포트 번호는 443이다.

11. 캐쉬를 제어하는 HTTP헤더필드
- AGE : 프로킨서버(프록시 서버, 중계서버)에 캐쉬하는 기한을 설정한다. 10은 10초. ☆
- Cache-Control : 캐쉬의 제어를 행한다. ☆
- Expires : 리스폰의 유효기간을 설정한다. ☆

12. 리다이렉트의 지정방법 (옳지 않은 것)
- JavaScript로 전송처를 지정할 수 있다.
- <link>태그로 전송처를 지정할 수 없고, CSS 참조에 사용한다. ★
- <meta>태그로 전송처를 지정할 수 있다.
- Location헤더필드로 전송처를 지정할 수 있다. (리다이렉트 사키의 URL) 
- Referer헤더필드로 전송처를 지정할 수 없고, 전 페이지의 URL ★

. 주된 HTTP헤더 필드
- Accept-Language : 브라우저가 우케이레 가능한 언어 ★
- Accept : 클라이언트가 우케이레 가능한 컨텐츠 타입 ★
- Age : 프로킨서버에 캐쉬하는 초수 ★
- Authoriztion : 인증정보 ★
- Cache-Control : 캐쉬의 제어를 행한다. ★
- Content-Length : 메세지보디의 사이즈를 설정 ★
- Exprise : 리소스의 유효기한 ★
- Location : 리다이렉트처의 URL ★
- Referer : 전 페이지의 URL ★

. HTML5의 사용 선언하는 문서형선언(DOCTYPE선언)
- <!DOCTYPE html> ★

. HTML5에서 추장되고 있는 문자 코드
- UTF-8

. 이하를 표시하는 문자실체참조의 조합
    HTML에서는, 태그를<>으로 감싼다.
HTML에서는, 태그를&lt;&gt;으로 감싼다. ★
반각 스페이스 : &nbsp;
< : &lt; ★
> : &gt; ★
& : &amp; ★
" : &quot;

. HTML 문서를 이용하고 있는 언어에 일본어 지정하는 방법
<html lang="ja"> ★

. HTML5, 또는 HTML4.01의 문자코드 지정 방법
- <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> (4.01) ★
- <meta charset="UTF-8"> (5) ★

. meta요소의 설명 (틀린 것 고르는 문제)
- name="roboots"로 검색엔진(크롤러)에 대한 설정을 할 수 있다.
- name="description"으로 페이지의 설명을 기술할 수 있다.
- charset속성으로 문자코드를 지정할 수 있다.
- http-equiv="content-security-policy"으로 세큐리티 폴리시를 설정할 수 있다.
- http-equiv="refresh"으로 동페이지를 다시 읽을 수 있는게 아니라, 설정한 시간을 경과한 후에 어떤 페이지로 리다이렉트할 것인가를 설정. ★

. head요소의 자요소로서 정의가능한 조합
- title, meta, style, link
base : 대상URL의 기점이 되는 URL을 설정
meta : Web페이지에 관한 정보를 담는다. ☆
style : CSS에 의한 스타일을 기술 ☆
title : Web페이지의 타이틀을 설정 ☆
  브라우저 탭에 나타나는 제목
link : 외부 리소스(주로 CSS파일)과의 리레숀(관계, relation) 설정 ☆

. Data URI스키마의 설명(틀린 것 찾는)
- HTML문서 내에서만 사용할 수 있는 것이 아닌, HTML이나 CSS에 외부 리소스를 담기 위한 방법 ★
- 브라우저와 Web서버의 통신회수를 줄이는 것이 가능하다.
- 파일의 종류에 따라 사이즈가 커진다.(동영상 파일을 담을 경우에는 Base64화가 필요하여 사이즈가 커진다.) 
- 동영상 데이터의 경우에는 해시값화를 한 값을 설정하는 것이 아니고, Base64화한다. ★
- 외부 리소스는 파일마다의 개별 캐쉬는 행할 수 없다.

. Data URI스키마 완성
    [  data:  ]image/png;base64, iVBORw0KGgoAA..... ★
  data: [미디어타입][;base64], 데이터

. form요소에 설정 가능한 속성 (틀린 것 찾는)
- action
- method
- id
- data-target
- XXXXX href XXXXX(href 속성은 링크사키를 지정하는 속성)

. DOM에 관한 설명 옳은 것 
- 요소의 속성을 조작할 수 있다. ★
- 이벤트를 제어할 수 있다. ★
- XML을 조작할 수 있다. ★
요소의 추가, 삭제
속성의 조작
이벤트의 처리

. 이벤트의 종류를 식별하기 위한 요소를 준비하고 싶다. 커스텀데이터를 사용하는 경우의 키워드
<ul>
	<li [  data  ]-pet-category="cat">고양이</li> ★
</ul>
주로 css나 자바스크립트에서 html에 접근할 때 사용하기 위해 준비함.

. 마이크로 데이터의 설명
- HTML 문서에 기계가 읽을 수 있는 데이터를 담는 것이 가능하다. ★
itemscope : 마이크로 데이터를 적용하는 범위를 지정. 보통 itemtype과 병술한다.
itemtype : 마이크로 데이터의 어휘를 지정
itemprop : 아이템의 프로퍼티명

. HTTP 리퀘스트, 리스폰의 설명 (틀린 것 찾는)
- 복수 리퀘스트를 통한 상태를 유지하는 스테이트풀(フル,full)통신이 아니고, 일련의 리퀘스트, 리스폰을 종료하면 사용한 상태를 폐기한다. ★
- 브라우저에서 리퀘스트를 개시하는 풀(プル,poll)형통신이 있다.
- ID와 패스워드를 이용하여 인증이 가능하다.
- HTTP헤더필드에 캐쉬를 설정하는 것이 가능하다.
- HTTP/2에서는 통신속도의 향상을 기대할 수 있다.

. 세션 설명 (틀린 것 찾는)
- 세션은 클라이언트/서버간에 스테이트레스통신을 행하기 위한 구조가 아니다. ★
- 세션을 사용하는 것으로 복수의 리퀘스트에 대한 인증정보 등의 상태관리를 행할 수 있다.
- 세션ID와 HTTP쿠키의 관리방법에 문제가 있을 경우, 세션-하이잭션 당할 위험이 있다.
- 세션ID는 명시적으로 소거하지 않는 한 계속 보지되는 것이 아니고, 일정 시간이 경과하면 서버측에서 폐기되어 무효화 된다. ★
- Web 서버는 세션ID와 브라우저를 관련지어 관리하는 것으로, 브라우저 단위로 상태관리를 행한다.

. Ajax의 설명
- 유저의 조작과 병행하여 서버와 야리토리 할 수 있다. ★
- JavaScript의 구조 오브젝트인 XMLHttpRequest를 이용한다. ★
- Web페이지 전체를 취득하지 않고, 데이터만 취득한다.
Ajax : (Asynchronous JavaScript + XML)
비동기통신에 의한 서버와 데이터의 야리토리를 행하고, 동적인 페이지의 카키카에 등을 행하는 기술

. Ajax를 이용한 경우의 메리트 (틀린 것 찾는)
- 데이터 취득에 따라 화면전이가 불필요하게 되어 유저의 대기시간을 삭감할 수 있다.
- 유저의 조작과 병행하여 Web 페이지의 일부를 갱신할 수 있다.
- 데이터만의 통신이기 때문에 네트워크 및 서버의 부담을 경감할 수 있다.
- 유저의 조작에 응한 보다 インタラクティブ(interactive 인터랙티브 상호작용적인)한 Web페이지를 작성할 수 있다.
- Ajax는 세큐리티 향상을 시키기 위한 목적이 아니다. ★

. MVC아키텍쳐의 설명 (틀린 것 찾는)
- MVC는 설게패턴의 일종으로 프로그램을 3종류의 부분으로 분할하여 설계한다.
- Model는 업무처리나 업무데이터를 담당한다.
- View는 화면표시를 담당한다.
- Controller은 데이터베이스로의 접근을 담당하는 것이 아니고, Model과 View로의 조작 후리와케를 담당한다. ★
- MVC를 이용하는 것으로 프로그램의 재사용성이나 메인테넌스성이 향상할 가능성이 있다.

. Base64의 설명 (틀린 것 찾는)
- 바이너리데이터를 텍스트데이터로 엔코드하는 방법 중 하나이다.
- Basic인증에서는 Base64가 사용되고 있다.
- Data URI스키마에서 화면 데이터 등을 HTML, CSS에 담을 경우 Base64가 사용되고 있다.
- 전자 메일에서 바이너리형식의 첨부파일을 송신할 경우 Base64가 사용되고 있다.
- Base64로 엔코드하면 파일 사이즈가 원래 사이즈의 4/3가 된다. 따라서 사이즈는 증가한다. ★

. Web으로 취급하는 것이 가능한 동영상 파일 포멧으로 알맞은 것 전부
- PNG ★
- JPEG ★
- SVG ★
- EPS(어도비 일러스트 관련)
- TIFF(웹이 아닌 인쇄용 )

. GIF의 설명
- 256색 이하의 표현이 가능하다. ★
- 애니메이션의 표현이 가능하다. ★
- 투명 가능하다.
- Windows 표준은 아니다.

. 동화파일포멧을 구분하여 사용할 때의 고려점
- 256색 이하로 표현이 가능한 동화의 경우, 파일 사이즈가 작은 GIF가 적절하다. ★
- BMP는 일반적으로 압축하지 않고 파일을 생성하기 때문에 파일 사이즈가 크고, Web사이트에서는 사용되지 않는다. ★
- 회선이 저속인 환경에서 동화를 표시할 경우, 인타레-스(홀수 짝수, 동시에)에 대응한 GIF나 PNG가 적절하다. ★
- 애니메이션 기능을 사용할 경우에는 GIF를 사용한다.
- 다소의 동화열화가 문제가 되지 않을 경우에는 비가역압축(압축률이 좋으나 해동 후 열화)으로 풀컬러에 대응한 JPEG가 적절하다.
BMP는 Windows의 표준 동화포멧
GIF 256색까지 표현 가능하지만 용량이 작음, 가역압축
PNG는 GIF의 代替(だいたい)로 W3C가 추장하는 동화 포멧, 가역압축

. 동화파일포멧의 하나인 SVG의 특징 (틀린 것 찾는)
- XML로 기술된다.
- 확대, 축소하여도 동화가 열화하지 않는다.
- CSS나 JavaScript에 의하여 제어할 수 있다.
- SVG는 비트맵 동화 방식이 아닌 벡터 동화 방식. ★
- 사진과 같은 복잡하고 다채로운 색을 사용하는 표현에는 적합하지 않고(파일이 겁나 커짐), 지도, 아이콘, 로고 등에 적절하다. ★

. Web사이트로의 부정, 공격수단과 그 위협의 조합으로 맞는 것
1. SQL인잭션 - は. 공격자에 의한 악의적인 SQL가 실행되어 데이터베이트 내부의 정보 유출, 개정, 소거가 발생할 위험이 있다.
2. 크로스사이트・리퀘스트・포제리(Forgeries) (CSRF) - ろ.공격자에 의하여 유저가 함정 사이즈에 유도되어
    인터넷뱅킹의 송금처리 등의 중요한 처리를 유저가 의도하지 않은 실행을 당해버리는 위험이 있다.
3. 크로스사이트 스크립트팅(XSS) - い.공격자에 의하여 부정한 스크립트가 Web페이지에 담겨져 다른 유저의 브라우저상에서 실행되어 버리고
    가짜 웹페이지가 표시되어 버리는 위험이 있다.

. 크로스사이트 스크립팅(XSS)의 대책 (잘못된 것 찾는)
- 클라이언트측 및 서버측에서 입력치의 체크를 행한다.
- Web페이지에 출력하는 모든 요소에 대하여 특수문자로 이스케이프 처리를 施す(ほどこす) (대책 등을) 세운다.
- HTTP쿠키에 HttpOnly속성을 설정한다.
- script요소의 내용을 동적으로 생성하지 않는다.
- HTTP리스폰헤더의 Referer필드에 문자코드를 설정하여도 아무 의미 없다. 링크되어 있는 元의 리소스 URL를 가르킬 뿐이다. ★

. W3C가 표준화하고 있는 기술로서 바른 것
- DOM ★
- HTML ★
- CSS ★

. 벤더프리픽스의 설명
- 브라우저벤더가 시험적기능 등을 제공할 때에 사용한다. ★

. SST/TLS의 설명 (잘못된 것)
- 공통키암호방식을 이용하고 있다.
- 공개키암호방식을 이용하고 있다.
- 인증서를 이용한다.
- 도청대책이 된다.
- Directory traversal attack (ディレクトリトラバーサル) 대책이 안 된다. ★

.Web사이트 전체의 스타일을 CSS파일에 모아서 정의하여 HTML에서 읽어들일 경우의 기술
<link rel= "[  stylesheet  ]" type="text/css" href="CSS/style.css">
rel속성에서는 링크할 파일과의 관계를 정의한다.
type속성의 既定値(기정치, 디폴트값)는 test/css이므로 생략 가능.

.HTML내의 Web페이지 전체의 스타일을 정의할 경우의 기술 알맞은 것
-<style> h1 { color : red; } </style> ★
-<style type="text/css"> h1 { color : red; } </style> ★

. 특정 요소에 스타일을 지정하는 인라인스타일시트의 설명
- 스타일을 지정하는 요소에 style속성으로서 기술한다. ★
- 하나의 요소에 대하여 복수의 스타일을 지정할 수 있다. ★
- 동 페이지의 여러 요소를 한 번에 스타일 지정하는 것이 아니고, 하나에 복수의 스타일 지정
- 스타일이 중복될 경우에는 설정방법에 따라 우선순위가 결정된다.
        인라인스타일시트 > 외부스타일시트 또는 내부스타일 시트 > 유저스타일시트 > 유저에이전트스타일시트
인라인 스타일 시트 : 한 부분만 적용
  <span style="color : red; text-decoration : underline" }> h1내용 </span>
외부 스타일 시트
  <link rel="stylesheet" type="text/css" href="style.css">
내부 스타일 시트 : 페이지 전체의 span에 대하여 적용
  <style> span { color : red; } </style>
유저 스타일은 브라우저에서 유저가 설정한 값
유저 에이전트 스타일스트는 브라우저 기정치
외부와 내부는 우선 순위 같기 때문에 결국 나중에 적용된 게 적용

스타일 시트에 있어서 다른 CSS 파일을 읽어들일 경우의 기술
@import url("CSS파일의 URL");
@import url("CSS/style.css") 미디어타입;

<ul>
    <li></li>
    <li></li>
</ul>
ul { color : red; }
li { color : red; }
.className { color : red; }
#iDName { color : red; }
* { color : red; } <-유니버셜 샐렉터
[이 부분이 속성 샐렉터]
a[href *= "flm"]{ color : red; }
[href] href 속성 가지는 요소
[href = "flm"] 속성명 and 속성치의 완전일치
[href *= "flm"] 속성명 and  속성치를 포함하는 부분일치 "flm", "flm aab", "llf-flm"
[href ~= "flm"] 속성치가 여럿이어도 하나만 포함되면 가능 "flm", "flm aab", "dde llf flm"
[href |= "flm"] 속성치로 시작하는 요소 + 하이픈 사용 가능  "flm", "flm-aab", "flm-eee-dds"
[href ^= "flm"] 속성치로 시작되는 요소 "flm", "flm aab", "flm-dde"
[href $= "flm"] 속성치로 종료되는 요소 "flm", "aab flm", "dde-flm"

. button:horver { color : red;} 疑似(의사 클래스)
link:미방문 링크
visited:방문한 링크
active:마우스로 누르고 있을 때
horver:마우스 올려뒀을 때
focus:입력창 클릭해서 커서 활성화 시켰을 때

<div>
    <h4>NEWS</h4>
    <p>한글이지롱</p>
    <p>english</p>
</div>
한글이지롱 빨갛게
p:nth-child(2) { color : red; }
p:first-of-type { color : red; }
※child와 of-type의 차이점 : type는 같은 종류의 요소만 포함한다.
p요소에 대한 스타일이므로 p만 적용된다..?

:nth-child(n)
:nth-last-child(n)
:nth-of-type(n)
:nth-last-of-type(n)
:first-child
:last-child
:first-of-type
:last-of-type


















